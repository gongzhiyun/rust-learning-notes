# Rust 闭包：捕获变量的三种姿势

**Fn、FnMut、FnOnce 到底怎么选？**

闭包能"记住"外部变量，但记住的方式有三种：只读（Fn）、可改（FnMut）、消耗（FnOnce）。Rust 会根据你对变量的操作自动选择。

> **声明**：本文所呈现的代码示例，旨在便于叙事，故而进行了诸多简化处理。此类示例与实际业务场景并无关联，还望各位勿作无端抬杠之举。

## 1. 核心概念

### 什么是捕获？

```rust
let discount = 0.8;
let apply = |price: f64| price * discount;  // 闭包"捕获"了 discount

println!("{}", apply(100.0));  // 80.0
```

闭包能访问外部的 `discount`，这就是"捕获"。Rust 根据你怎么用变量，自动选择捕获方式。

### 三种捕获方式

#### Fn：不可变借用

```rust
let name = String::from("Alice");
let greet = || println!("Hello, {}", name);  // 只读 name

greet();
greet();  // 可以多次调用
println!("{}", name);  // name 还能用
```

- **捕获方式**：`&T`（不可变借用）
- **成本**：零成本，只是借用
- **限制**：不能修改捕获的变量

> **为什么叫 Fn？**
> Fn 是 trait 名，表示"可以像普通函数一样多次调用"。因为只是借用，所以随便调。

#### FnMut：可变借用

```rust
let mut count = 0;
let mut increment = || {  // 修改 count，闭包要 mut
    count += 1;
    println!("Count: {}", count);
};

increment();  // Count: 1
increment();  // Count: 2
```

- **捕获方式**：`&mut T`（可变借用）
- **成本**：零成本，只是借用
- **限制**：闭包本身必须声明为 `mut`

> **为什么闭包要 mut？**
> 闭包需要可变借用捕获的变量，所以调用闭包时需要可变引用。Rust 要求你显式标记这种可变性。

#### FnOnce：获取所有权

```rust
let data = vec![1, 2, 3];
let consume = || drop(data);  // data 被移动进闭包

consume();
// consume();  // 错误！data 已经被消耗
```

- **捕获方式**：获取所有权
- **成本**：可能有移动成本
- **限制**：只能调用一次

> **为什么只能调用一次？**
> 闭包拿走了变量的所有权，第一次调用时变量就被消耗了（比如 drop 掉），第二次调用时变量已经不存在了。

## 2. 底层原理

### trait 定义

```rust
// FnOnce：获取所有权，只能调用一次
pub trait FnOnce<Args> {
    type Output;  // 返回值类型
    
    // 参数 self 表示闭包本身被消耗
    fn call_once(self, args: Args) -> Self::Output;
}

// FnMut：可变借用，可以多次调用
// 继承 FnOnce，所以 FnMut 也能当 FnOnce 用
pub trait FnMut<Args>: FnOnce<Args> {
    // 参数 &mut self 表示可变借用闭包
    fn call_mut(&mut self, args: Args) -> Self::Output;
}

// Fn：不可变借用，可以多次调用
// 继承 FnMut，所以 Fn 也能当 FnMut 和 FnOnce 用
pub trait Fn<Args>: FnMut<Args> {
    // 参数 &self 表示不可变借用闭包
    fn call(&self, args: Args) -> Self::Output;
}
```

继承关系：`Fn: FnMut: FnOnce`。实现了 `Fn` 的闭包也实现了 `FnMut` 和 `FnOnce`，但反过来不成立。

### 为什么这样设计？

```rust
// 要求 Fn：只能传入 Fn 闭包
fn call_twice<F>(f: F)
where
    F: Fn(),  // 需要多次调用
{
    f();
    f();
}

let x = 10;
call_twice(|| println!("{}", x));  // OK，闭包是 Fn

// 下面这些都不行：
// let mut y = 0;
// call_twice(|| y += 1);  // 错误！FnMut 不满足 Fn
// call_twice(|| drop(x));  // 错误！FnOnce 不满足 Fn
```

函数要求 `Fn`，说明它需要多次调用且不修改状态。只有 `Fn` 闭包满足。

但如果函数只要求 `FnOnce`：

```rust
fn call_once<F>(f: F)
where
    F: FnOnce(),  // 只调用一次
{
    f();
}

// 任何闭包都能传入
let x = 10;
call_once(|| println!("{}", x));  // Fn 闭包 OK

let mut y = 0;
call_once(|| y += 1);  // FnMut 闭包 OK

let z = vec![1, 2, 3];
call_once(|| drop(z));  // FnOnce 闭包 OK
```

`FnOnce` 是最宽松的要求，所有闭包都至少能调用一次。

### 编译器如何处理 trait 转换？

当你把 `Fn` 闭包传给要求 `FnOnce` 的函数时，编译器做了什么？

```rust
fn call_once<F>(f: F)
where
    F: FnOnce(),
{
    f();  // 调用 call_once(self)
}

let x = 10;
let closure = || println!("{}", x);  // 这是一个 Fn 闭包
call_once(closure);
```

关键在于标准库的自动实现：

```rust
// 标准库为所有 Fn 类型自动实现了 FnOnce
impl<F: Fn<Args>> FnOnce<Args> for F {
    type Output = <F as Fn<Args>>::Output;
    
    // 当 FnOnce 被调用时，实际调用的是 Fn::call
    fn call_once(self, args: Args) -> Self::Output {
        self.call(args)  // 转发给 Fn::call
    }
}

// 类似地，Fn 也自动实现了 FnMut
impl<F: Fn<Args>> FnMut<Args> for F {
    fn call_mut(&mut self, args: Args) -> Self::Output {
        self.call(args)  // 转发给 Fn::call
    }
}
```

所以当你调用 `call_once(closure)` 时：
1. `closure` 的类型是 `Fn`
2. 编译器发现 `Fn` 自动实现了 `FnOnce`（通过上面的 blanket implementation）
3. 调用 `call_once(self)` 时，实际执行的是 `self.call()`
4. 虽然 `self` 被移动了，但因为 `Fn` 闭包只是借用捕获的变量，移动闭包本身是安全的

> **什么是 blanket implementation？**
> 标准库为所有满足某个条件的类型自动实现 trait。比如 `impl<F: Fn> FnOnce for F` 表示"所有实现了 `Fn` 的类型自动实现 `FnOnce`"。

## 3. move 关键字

前面说的三种捕获方式都是编译器自动选择的。但有时候，你想强制闭包获取所有权，而不是借用，这时候就需要 `move` 关键字。

### 强制获取所有权

```rust
let name = String::from("Alice");

// 不加 move：闭包借用 name
let greet = || println!("{}", name);
greet();
println!("{}", name);  // name 还能用

// 加 move：闭包获取 name 的所有权
let greet = move || println!("{}", name);
greet();
// println!("{}", name);  // 错误！name 已经被移动
```

`move` 关键字强制闭包获取所有捕获变量的所有权，即使闭包只是读取。

### 什么时候用 move？

#### 场景 1：多线程

```rust
use std::thread;

let data = vec![1, 2, 3];

// 错误！闭包借用 data，但新线程可能活得比当前函数长
// let handle = thread::spawn(|| println!("{:?}", data));

// 正确：move 强制获取所有权
let handle = thread::spawn(move || {
    println!("{:?}", data);
});

handle.join().unwrap();
```

新线程可能在当前函数结束后还在运行。闭包只是借用 `data` 的话，函数结束后 `data` 就被释放了，新线程会访问无效内存。

#### 场景 2：返回闭包

```rust
// 错误！闭包借用局部变量 x
// fn make_adder(x: i32) -> impl Fn(i32) -> i32 {
//     |y| x + y  // x 是局部变量，函数结束后就没了
// }

// 正确：move 强制获取所有权
fn make_adder(x: i32) -> impl Fn(i32) -> i32 {
    move |y| x + y  // x 被移动进闭包
}

let add_5 = make_adder(5);
println!("{}", add_5(10));  // 15
```

函数返回闭包时，闭包可能在函数结束后还在使用。闭包借用局部变量会出现悬垂引用。

#### 场景 3：Copy 类型的特殊情况

```rust
let x = 5;  // i32 实现了 Copy

let f = move || println!("{}", x);  // move 只是复制
f();
println!("{}", x);  // x 还能用！
```

对于实现了 `Copy` 的类型（如 `i32`、`bool`），`move` 只是复制值，原变量还能继续使用。

## 4. 常见陷阱

### 陷阱 1：忘记 mut

```rust
let mut count = 0;

// 错误！闭包修改了 count，但没有声明为 mut
// let increment = || count += 1;

// 正确：闭包声明为 mut
let mut increment = || count += 1;
increment();
```

**理解**：闭包修改捕获的变量时，需要可变借用，所以闭包本身必须声明为 `mut`。

### 陷阱 2：move 后还想用

```rust
let data = vec![1, 2, 3];
let f = move || println!("{:?}", data);
f();

// 错误！data 已经被移动
// println!("{:?}", data);
```

**正确做法**：

```rust
let data = vec![1, 2, 3];
let data_clone = data.clone();  // 克隆一份给闭包

let f = move || println!("{:?}", data_clone);
f();

println!("{:?}", data);  // 原数据还能用
```

**理解**：`move` 会转移所有权，后续还要用就先克隆一份。

### 陷阱 3：循环中的闭包

```rust
let mut closures = vec![];

for i in 0..3 {
    // 错误！闭包借用了 i，但 i 在循环结束后就失效了
    // closures.push(|| println!("{}", i));
    // 编译器报错：closure may outlive the current function
    
    // 正确：move 让每个闭包拥有自己的 i
    closures.push(move || println!("{}", i));
}

for f in closures {
    f();  // 输出 0, 1, 2
}
```

**理解**：循环变量 `i` 在每次迭代时都是同一个变量，只是值在变化。不加 `move` 时，所有闭包都借用同一个 `i`，但循环结束后 `i` 就不存在了。加 `move` 后，每个闭包拥有自己的 `i` 副本（`i32` 实现了 `Copy`）。

### 陷阱 4：FnOnce 只能调用一次

```rust
let data = vec![1, 2, 3];
let consume = || drop(data);

consume();
// consume();  // 错误！FnOnce 只能调用一次
```

**正确做法**：

```rust
let data = vec![1, 2, 3];
let print = || println!("{:?}", data);  // 不消耗变量

print();
print();  // OK
```

**理解**：闭包需要多次调用，就别在闭包内消耗捕获的变量。

## 5. 最佳实践

1. **让编译器自动选择**：不需要手动指定 `Fn`、`FnMut` 或 `FnOnce`，编译器会根据闭包体自动推断
2. **多线程必须 move**：传递给 `thread::spawn` 的闭包必须加 `move`
3. **Copy 类型可以放心 move**：`i32`、`bool` 等 `Copy` 类型，`move` 只是复制，不影响原变量
4. **需要多次调用就别消耗**：闭包需要多次调用，别在闭包内 `drop` 或移动捕获的变量

## 总结

1. **三种捕获方式**：Fn（只读）、FnMut（可改）、FnOnce（消耗），编译器会自动选择
2. **move 关键字**：强制获取所有权，多线程和返回闭包时必须使用
3. **Copy 类型特殊**：move 对 Copy 类型只是复制，原变量还能用
