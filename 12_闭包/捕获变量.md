# Rust 闭包：捕获变量的三种姿势

**Fn、FnMut、FnOnce 到底怎么选？**

闭包能"记住"外部变量，但记住的方式有三种：只读（Fn）、可改（FnMut）、消耗（FnOnce）。Rust 会根据你对变量的操作自动选择。

## 1. 核心概念

### 什么是捕获？

```rust
let discount = 0.8;

// 闭包"捕获"了外部变量 discount
let apply = |price: f64| price * discount;

println!("{}", apply(100.0));  // 80.0
```

闭包 `apply` 能访问外部的 `discount`，这就是"捕获"。Rust 不会无脑复制变量，而是根据你的使用方式选择捕获策略。

### 三种捕获方式

#### Fn：不可变借用

```rust
let name = String::from("Alice");

// 闭包只读取 name，编译器选择不可变借用
let greet = || println!("Hello, {}", name);

greet();
greet();  // 可以多次调用
println!("{}", name);  // name 还能用
```

闭包通过 `&T` 借用变量，不能修改，零成本。

> **为什么叫 Fn？**
> Fn 是 Rust 的 trait，表示"可以像普通函数一样多次调用"。因为只是借用，所以可以随便调用。

#### FnMut：可变借用

```rust
let mut count = 0;

// 闭包修改 count，编译器选择可变借用
let mut increment = || {
    count += 1;
    println!("Count: {}", count);
};

increment();  // Count: 1
increment();  // Count: 2
```

闭包通过 `&mut T` 借用变量，闭包本身必须声明为 `mut`，零成本。

> **为什么闭包要 mut？**
> 因为闭包内部修改了捕获的变量，闭包本身的状态发生了变化。Rust 要求你显式标记这种变化。

#### FnOnce：获取所有权

```rust
let data = vec![1, 2, 3];

// 闭包消耗 data，编译器选择获取所有权
let consume = || {
    drop(data);  // data 被移动进闭包
};

consume();
// consume();  // 错误！data 已经被消耗
```

闭包获取变量的所有权，只能调用一次。

> **为什么只能调用一次？**
> 因为闭包拿走了变量的所有权，第一次调用时变量就被消耗了（比如 drop 掉），第二次调用时变量已经不存在了。

## 2. 底层原理

### trait 定义

```rust
// FnOnce：获取所有权，只能调用一次
// 参数 self 表示闭包本身被消耗
pub trait FnOnce<Args> {
    type Output;  // 返回值类型
    fn call_once(self, args: Args) -> Self::Output;
}

// FnMut：可变借用，可以多次调用
// 继承 FnOnce，所以也能当 FnOnce 用
pub trait FnMut<Args>: FnOnce<Args> {
    fn call_mut(&mut self, args: Args) -> Self::Output;
}

// Fn：不可变借用，可以多次调用
// 继承 FnMut，所以也能当 FnMut 和 FnOnce 用
pub trait Fn<Args>: FnMut<Args> {
    fn call(&self, args: Args) -> Self::Output;
}
```

继承关系：`Fn: FnMut: FnOnce`。实现了 `Fn` 的闭包也实现了 `FnMut` 和 `FnOnce`，但反过来不成立。

### 为什么这样设计？

```rust
// 接受 Fn 的函数也能接受 FnMut 和 FnOnce
fn call_twice<F>(f: F)
where
    F: Fn(),  // 要求可以多次调用
{
    f();
    f();
}

let x = 10;
call_twice(|| println!("{}", x));  // OK，闭包是 Fn
```

函数要求 `Fn`，说明它需要多次调用闭包。`FnMut` 和 `FnOnce` 不满足要求。

但函数只要求 `FnOnce` 时：

```rust
fn call_once<F>(f: F)
where
    F: FnOnce(),  // 只调用一次
{
    f();
}

let x = vec![1, 2, 3];
call_once(|| drop(x));  // OK，闭包是 FnOnce
```

任何闭包都能传入，因为所有闭包都至少能调用一次。

### 编译器如何选择？

```rust
let x = String::from("hello");

// 只读 → Fn
let f1 = || println!("{}", x);

// 修改 → FnMut
let mut y = 0;
let mut f2 = || y += 1;

// 消耗 → FnOnce
let f3 = || drop(x);
```

规则：
1. 闭包消耗了变量（如 `drop`、`move` 到其他地方）→ `FnOnce`
2. 闭包修改了变量 → `FnMut`
3. 闭包只读取变量 → `Fn`

## 3. move 关键字

### 强制获取所有权

```rust
let name = String::from("Alice");

// 不加 move：闭包借用 name
let greet = || println!("{}", name);
greet();
println!("{}", name);  // name 还能用

// 加 move：闭包获取 name 的所有权
let greet = move || println!("{}", name);
greet();
// println!("{}", name);  // 错误！name 已经被移动
```

`move` 关键字强制闭包获取所有捕获变量的所有权，即使闭包只是读取它们。

### 什么时候用 move？

#### 场景 1：多线程

```rust
use std::thread;

let data = vec![1, 2, 3];

// 错误！闭包借用 data，但新线程可能活得比当前函数长
// let handle = thread::spawn(|| {
//     println!("{:?}", data);
// });

// 正确：move 强制获取所有权
let handle = thread::spawn(move || {
    println!("{:?}", data);
});

handle.join().unwrap();
```

新线程可能在当前函数结束后还在运行。闭包只是借用 `data` 的话，函数结束后 `data` 就被释放了，新线程会访问无效内存。

#### 场景 2：返回闭包

```rust
// 错误！闭包借用局部变量 x
// fn make_adder(x: i32) -> impl Fn(i32) -> i32 {
//     |y| x + y  // x 是局部变量，函数结束后就没了
// }

// 正确：move 强制获取所有权
fn make_adder(x: i32) -> impl Fn(i32) -> i32 {
    move |y| x + y  // x 被移动进闭包
}

let add_5 = make_adder(5);
println!("{}", add_5(10));  // 15
```

函数返回闭包时，闭包可能在函数结束后还在使用。闭包借用局部变量会出现悬垂引用。

#### 场景 3：Copy 类型的特殊情况

```rust
let x = 5;  // i32 实现了 Copy

// move 对 Copy 类型只是复制，不是移动
let f = move || println!("{}", x);
f();
println!("{}", x);  // x 还能用！
```

对于实现了 `Copy` 的类型（如 `i32`、`bool`），`move` 只是复制值，原变量还能继续使用。

## 4. 常见陷阱

### 陷阱 1：忘记 mut

```rust
let mut count = 0;

// 错误！闭包修改了 count，但没有声明为 mut
// let increment = || count += 1;

// 正确：闭包声明为 mut
let mut increment = || count += 1;
increment();
```

闭包修改捕获的变量时，闭包本身的状态也在变化，必须声明为 `mut`。

### 陷阱 2：move 后还想用

```rust
let data = vec![1, 2, 3];

let f = move || println!("{:?}", data);
f();

// 错误！data 已经被移动
// println!("{:?}", data);
```

**正确做法**：

```rust
let data = vec![1, 2, 3];

// 克隆一份给闭包
let data_clone = data.clone();
let f = move || println!("{:?}", data_clone);
f();

println!("{:?}", data);  // 原数据还能用
```

`move` 会转移所有权，后续还要用就先克隆一份。

### 陷阱 3：循环中的闭包

```rust
let mut closures = vec![];

// 错误！所有闭包都捕获同一个 i 的引用
// for i in 0..3 {
//     closures.push(|| println!("{}", i));
// }

// 正确：move 让每个闭包拥有自己的 i
for i in 0..3 {
    closures.push(move || println!("{}", i));
}

for f in closures {
    f();  // 输出 0, 1, 2
}
```

不加 `move` 时，所有闭包都借用同一个 `i`，循环结束后 `i` 就失效了。加 `move` 后，每个闭包拥有自己的 `i` 副本（`i32` 实现了 `Copy`）。

### 陷阱 4：FnOnce 只能调用一次

```rust
let data = vec![1, 2, 3];

let consume = || drop(data);

consume();
// consume();  // 错误！FnOnce 只能调用一次
```

**正确做法**：

```rust
let data = vec![1, 2, 3];

// 如果需要多次调用，不要消耗变量
let print = || println!("{:?}", data);
print();
print();  // OK
```

闭包需要多次调用，就别在闭包内消耗捕获的变量。

## 5. 最佳实践

1. **让编译器自动选择**：不需要手动指定 `Fn`、`FnMut` 或 `FnOnce`，编译器会根据闭包体自动推断
2. **多线程必须 move**：传递给 `thread::spawn` 的闭包必须加 `move`
3. **Copy 类型可以放心 move**：`i32`、`bool` 等 `Copy` 类型，`move` 只是复制，不影响原变量
4. **需要多次调用就别消耗**：闭包需要多次调用，别在闭包内 `drop` 或移动捕获的变量

## 总结

1. **三种捕获方式**：Fn（只读）、FnMut（可改）、FnOnce（消耗），编译器会自动选择
2. **move 关键字**：强制获取所有权，多线程和返回闭包时必须使用
3. **Copy 类型特殊**：move 对 Copy 类型只是复制，原变量还能用
