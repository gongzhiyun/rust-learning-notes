# Rust 闭包：编译器把它变成了什么？

**揭秘闭包的底层实现**

Rust 的闭包不是什么魔法。编译器看到闭包，就生成一个匿名结构体 + trait 实现。搞懂这个，你就明白为什么有的闭包能 Copy，有的不能，为什么有的只能调用一次。

## 1. 核心概念

### 闭包的本质

```rust
let x = 10;
let add_x = |y| x + y;

println!("{}", add_x(5));  // 15
```

编译器看到这个闭包，会做什么？它会生成类似这样的代码：

```rust
// 编译器生成的匿名结构体
struct ClosureEnv {
    x: i32,  // 捕获的变量
}

// 实现 Fn trait
impl Fn<(i32,)> for ClosureEnv {
    type Output = i32;
    
    fn call(&self, args: (i32,)) -> i32 {
        let y = args.0;
        self.x + y  // 闭包体
    }
}

// 创建闭包实例
let add_x = ClosureEnv { x: 10 };
println!("{}", add_x.call((5,)));  // 15
```

看出来了吗？
- 闭包 = 结构体 + trait 实现
- 结构体字段存捕获的变量
- 闭包体变成 trait 方法
- 调用闭包 = 调用 trait 方法

> **为什么这样设计？**
> 闭包既能调用（像函数），又能存状态（像结构体）。编译器为每个闭包生成专门的代码，零运行时开销。

### 不同捕获方式的实现

#### Fn：不可变借用

```rust
let name = String::from("Alice");
let greet = || println!("Hello, {}", name);
```

编译器生成：

```rust
struct ClosureEnv<'a> {
    name: &'a String,  // 不可变引用
}

impl<'a> Fn<()> for ClosureEnv<'a> {
    fn call(&self, _args: ()) {
        println!("Hello, {}", self.name);
    }
}

let greet = ClosureEnv { name: &name };
```

闭包通过引用捕获变量，零成本。

#### FnMut：可变借用

```rust
let mut count = 0;
let mut increment = || count += 1;
```

编译器生成：

```rust
struct ClosureEnv<'a> {
    count: &'a mut i32,  // 可变引用
}

impl<'a> FnMut<()> for ClosureEnv<'a> {
    fn call_mut(&mut self, _args: ()) {
        *self.count += 1;
    }
}

let mut increment = ClosureEnv { count: &mut count };
```

闭包通过可变引用捕获变量，调用时需要 `&mut self`。

#### FnOnce：获取所有权

```rust
let data = vec![1, 2, 3];
let consume = || drop(data);
```

编译器生成：

```rust
struct ClosureEnv {
    data: Vec<i32>,  // 拥有所有权
}

impl FnOnce<()> for ClosureEnv {
    fn call_once(self, _args: ()) {
        drop(self.data);  // 消耗 data
    }
}

let consume = ClosureEnv { data };
```

闭包拥有变量的所有权，调用时消耗 `self`，只能调用一次。

## 2. 零大小闭包

### 不捕获变量的闭包

```rust
let add = |x, y| x + y;
```

编译器生成：

```rust
struct ClosureEnv;  // 零大小类型（ZST）

impl Fn<(i32, i32)> for ClosureEnv {
    type Output = i32;
    
    fn call(&self, args: (i32, i32)) -> i32 {
        args.0 + args.1
    }
}

let add = ClosureEnv;
```

不捕获变量的闭包是零大小类型（Zero-Sized Type），不占内存。

> **什么是零大小类型？**
> 编译时存在，运行时不占内存。比如空结构体 `struct Empty;`，`size_of::<Empty>()` 是 0。编译器会把所有 ZST 的内存分配和复制操作优化掉。

### 函数指针转换

```rust
// 不捕获变量的闭包可以转换为函数指针
let add = |x, y| x + y;
let fn_ptr: fn(i32, i32) -> i32 = add;

println!("{}", fn_ptr(1, 2));  // 3
```

但捕获变量的闭包不能转换：

```rust
let z = 10;
let add_z = |x| x + z;

// 错误！捕获变量的闭包不能转换为函数指针
// let fn_ptr: fn(i32) -> i32 = add_z;
```

函数指针只是代码地址，不能带数据。捕获变量的闭包要存状态，转不了函数指针。

## 3. move 关键字的实现

### 不加 move

```rust
let x = String::from("hello");
let f = || println!("{}", x);
```

编译器生成：

```rust
struct ClosureEnv<'a> {
    x: &'a String,  // 借用
}
```

### 加 move

```rust
let x = String::from("hello");
let f = move || println!("{}", x);
```

编译器生成：

```rust
struct ClosureEnv {
    x: String,  // 拥有所有权
}
```

`move` 关键字改变了结构体字段的类型：从引用变成拥有所有权。

### Copy 类型的特殊情况

```rust
let x = 5;  // i32 实现了 Copy
let f = move || println!("{}", x);
```

编译器生成：

```rust
struct ClosureEnv {
    x: i32,  // 复制值
}

// 因为 i32 实现了 Copy，所以闭包也实现 Copy
impl Copy for ClosureEnv {}
impl Clone for ClosureEnv {
    fn clone(&self) -> Self {
        *self
    }
}
```

闭包捕获的所有变量都实现了 `Copy`，闭包本身也会自动实现 `Copy`。

## 4. 闭包的大小

### 捕获变量的大小

```rust
use std::mem::size_of_val;

let x = 10_i32;
let y = 20_i64;

let f1 = || println!("{}", x);
let f2 = || println!("{} {}", x, y);

println!("f1 size: {}", size_of_val(&f1));  // 4 字节（&i32）
println!("f2 size: {}", size_of_val(&f2));  // 16 字节（&i32 + &i64 + 对齐）
```

闭包的大小 = 捕获变量的大小之和（加上对齐）。

### move 闭包的大小

```rust
let s = String::from("hello");
let f = move || println!("{}", s);

println!("f size: {}", size_of_val(&f));  // 24 字节（String 的大小）
```

`move` 闭包拥有变量的所有权，大小等于变量本身的大小。

### 零大小闭包

```rust
let f = || println!("hello");

println!("f size: {}", size_of_val(&f));  // 0 字节
```

不捕获变量的闭包是零大小类型。

## 5. 闭包与泛型

### 接受闭包的函数

```rust
// 使用泛型 + trait bound
fn call_twice<F>(f: F)
where
    F: Fn(),
{
    f();
    f();
}

let x = 10;
call_twice(|| println!("{}", x));
```

编译器会为每个不同的闭包类型生成一份 `call_twice` 的代码（单态化）。

### 为什么不能用 trait 对象？

```rust
// 错误！闭包大小不固定
// fn make_closure() -> dyn Fn() {
//     || println!("hello")
// }

// 正确：用 Box 包装
fn make_closure() -> Box<dyn Fn()> {
    Box::new(|| println!("hello"))
}
```

每个闭包都是不同类型，大小也不同。`dyn Fn()` 是动态大小类型（DST），必须放在指针后面（`Box`、`&`）。

> **什么是动态大小类型？**
> 编译时大小未知的类型。比如 `str`、`[T]`、`dyn Trait`。只能通过指针访问：`&str`、`Box<dyn Trait>`。

## 6. 实际例子

### 例子 1：迭代器适配器

```rust
let numbers = vec![1, 2, 3, 4, 5];

// map 接受一个闭包
let doubled: Vec<_> = numbers.iter()
    .map(|x| x * 2)  // 闭包
    .collect();

println!("{:?}", doubled);  // [2, 4, 6, 8, 10]
```

编译器为 `|x| x * 2` 生成：

```rust
struct MapClosure;  // 零大小类型

impl Fn<(&i32,)> for MapClosure {
    type Output = i32;
    
    fn call(&self, args: (&i32,)) -> i32 {
        args.0 * 2
    }
}
```

闭包不捕获变量，就是零大小类型，零开销。

### 例子 2：状态机

```rust
fn make_counter() -> impl FnMut() -> i32 {
    let mut count = 0;
    
    move || {
        count += 1;
        count
    }
}

let mut counter = make_counter();
println!("{}", counter());  // 1
println!("{}", counter());  // 2
println!("{}", counter());  // 3
```

编译器生成：

```rust
struct Counter {
    count: i32,  // 捕获的变量
}

impl FnMut<()> for Counter {
    type Output = i32;
    
    fn call_mut(&mut self, _args: ()) -> i32 {
        self.count += 1;
        self.count
    }
}

fn make_counter() -> Counter {
    Counter { count: 0 }
}
```

闭包变成了一个有状态的结构体，每次调用都会修改内部状态。

### 例子 3：回调函数

```rust
struct Button {
    on_click: Box<dyn Fn()>,
}

impl Button {
    fn new<F>(on_click: F) -> Self
    where
        F: Fn() + 'static,
    {
        Button {
            on_click: Box::new(on_click),
        }
    }
    
    fn click(&self) {
        (self.on_click)();
    }
}

let message = String::from("Button clicked!");
let button = Button::new(move || {
    println!("{}", message);
});

button.click();  // Button clicked!
```

闭包被装箱（`Box<dyn Fn()>`），可以存储在结构体中。

## 7. 常见陷阱

### 陷阱 1：闭包类型不同

```rust
let f1 = || println!("hello");
let f2 = || println!("hello");

// 错误！f1 和 f2 是不同的类型
// let closures = vec![f1, f2];
```

**正确做法**：

```rust
// 用 trait 对象统一类型
let closures: Vec<Box<dyn Fn()>> = vec![
    Box::new(|| println!("hello")),
    Box::new(|| println!("world")),
];

for f in closures {
    f();
}
```

每个闭包都是独特类型，代码一样也不行。要存多个闭包，得用 trait 对象。

### 陷阱 2：闭包大小爆炸

```rust
let a = vec![1; 1000];
let b = vec![2; 1000];
let c = vec![3; 1000];

// 闭包捕获了三个大 Vec 的引用
let f = || {
    println!("{} {} {}", a.len(), b.len(), c.len());
};

println!("f size: {}", size_of_val(&f));  // 24 字节（3 个引用）
```

如果用 `move`：

```rust
let f = move || {
    println!("{} {} {}", a.len(), b.len(), c.len());
};

println!("f size: {}", size_of_val(&f));  // 72000 字节（3 个 Vec）
```

`move` 闭包拥有变量所有权，大小会暴增。只是读取的话，借用就够了。

### 陷阱 3：返回借用闭包

```rust
// 错误！闭包借用局部变量
// fn make_printer() -> impl Fn() {
//     let message = String::from("hello");
//     || println!("{}", message)  // message 是局部变量
// }

// 正确：move 获取所有权
fn make_printer() -> impl Fn() {
    let message = String::from("hello");
    move || println!("{}", message)
}
```

返回闭包时，闭包不能借用局部变量，必须用 `move` 获取所有权。

## 8. 最佳实践

1. **闭包就是结构体**：编译器生成的结构体 + trait 实现，没别的
2. **不捕获变量 = 零开销**：零大小类型，性能等同函数指针
3. **别 move 大对象**：`move` 转移所有权，捕获大对象会让闭包变胖
4. **返回闭包必须 move**：不然局部变量没了，闭包就悬空了

## 总结

1. **闭包 = 结构体 + trait**：编译器为每个闭包生成匿名结构体和 trait 实现
2. **零大小闭包**：不捕获变量的闭包是零大小类型，零运行时开销
3. **move 改变捕获方式**：从借用变成拥有所有权，影响闭包大小和生命周期
