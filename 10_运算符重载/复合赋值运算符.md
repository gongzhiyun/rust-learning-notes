# 复合赋值运算符重载

将算术运算与赋值结合的运算符（`+=`、`-=`、`*=` 等），通过实现 `std::ops` 中以 `Assign` 结尾的 trait 重载。

## 核心概念

### 与二元运算符的区别

| 特性 | 二元运算符 (`Add`) | 复合赋值 (`AddAssign`) |
| --- | --- | --- |
| 方法签名 | `fn add(self, rhs) -> Output` | `fn add_assign(&mut self, rhs)` |
| 所有权 | 消耗 `self`，返回新值 | 可变借用 `self`，原地修改 |
| 返回值 | `Self::Output` | `()` 无返回值 |

### Trait 签名

以 `AddAssign` 为例：

```rust
pub trait AddAssign<Rhs = Self> {
    fn add_assign(&mut self, rhs: Rhs);
}
```

- `&mut self`：原地修改左操作数
- `Rhs`：右操作数类型，默认为 `Self`
- 无返回值：直接修改而非创建新值

### 运算符对照表

| 运算符 | Trait | 方法 |
| --- | --- | --- |
| `+=` | `AddAssign` | `add_assign` |
| `-=` | `SubAssign` | `sub_assign` |
| `*=` | `MulAssign` | `mul_assign` |
| `/=` | `DivAssign` | `div_assign` |
| `%=` | `RemAssign` | `rem_assign` |
| `&=` | `BitAndAssign` | `bitand_assign` |
| `\|=` | `BitOrAssign` | `bitor_assign` |
| `^=` | `BitXorAssign` | `bitxor_assign` |
| `<<=` | `ShlAssign` | `shl_assign` |
| `>>=` | `ShrAssign` | `shr_assign` |

## 基本实现

```rust
use std::ops::AddAssign;

#[derive(Debug, PartialEq)]
struct Point { x: i32, y: i32 }

impl AddAssign for Point {
    fn add_assign(&mut self, other: Point) {
        self.x += other.x;
        self.y += other.y;
    }
}

fn main() {
    let mut p1 = Point { x: 1, y: 0 };
    let p2 = Point { x: 2, y: 3 };

    p1 += p2; // 调用 p1.add_assign(p2)

    assert_eq!(p1, Point { x: 3, y: 3 });
}
```

## 异构类型运算

利用 `Rhs` 泛型参数实现不同类型间的复合赋值：

```rust
use std::ops::AddAssign;

#[derive(Debug, PartialEq)]
struct Point { x: i32, y: i32 }

impl AddAssign<i32> for Point {
    fn add_assign(&mut self, scalar: i32) {
        self.x += scalar;
        self.y += scalar;
    }
}

fn main() {
    let mut p = Point { x: 1, y: 1 };
    p += 10; // Point += i32
    assert_eq!(p, Point { x: 11, y: 11 });
}
```

## 注意事项

### Add 与 AddAssign 相互独立

实现 `Add` 不会自动获得 `AddAssign`，需分别实现：

```rust
use std::ops::{Add, AddAssign};

#[derive(Debug, Clone, Copy, PartialEq)]
struct Point { x: i32, y: i32 }

// 实现 Add：支持 p1 + p2
impl Add for Point {
    type Output = Point;
    fn add(self, other: Point) -> Point {
        Point { x: self.x + other.x, y: self.y + other.y }
    }
}

// 实现 AddAssign：支持 p1 += p2
impl AddAssign for Point {
    fn add_assign(&mut self, other: Point) {
        *self = *self + other; // 可复用 Add 实现
    }
}
```

### 左操作数必须可变

```rust
let p1 = Point { x: 1, y: 2 };
let p2 = Point { x: 3, y: 4 };
// p1 += p2; // 错误！p1 不是 mut

let mut p1 = Point { x: 1, y: 2 };
p1 += p2; // 正确
```

### 右操作数的所有权

默认实现会消耗右操作数，如需保留可为引用实现：

```rust
impl AddAssign<&Point> for Point {
    fn add_assign(&mut self, other: &Point) {
        self.x += other.x;
        self.y += other.y;
    }
}

fn main() {
    let mut p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    p1 += &p2; // p2 仍可用
    println!("{:?}", p2);
}
```

## 总结

- 复合赋值运算符通过 `XxxAssign` trait 重载，原地修改左操作数
- 方法签名 `fn xxx_assign(&mut self, rhs)`，无返回值
- `Add` 与 `AddAssign` 相互独立，需分别实现
- 左操作数必须声明为 `mut`
