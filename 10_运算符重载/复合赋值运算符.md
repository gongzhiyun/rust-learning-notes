# 复合赋值运算符重载

复合赋值运算符（Compound Assignment Operators）是指将算术运算与赋值操作结合的运算符，例如 `+=`, `-=`, `*=` 等。

在 Rust 中，通过实现 `std::ops` 模块中以 `Assign` 结尾的 Trait 来重载这些运算符。

## 常用复合赋值运算符

| 运算符 | Trait | 方法名 | 说明 |
| :--- | :--- | :--- | :--- |
| `+=` | `std::ops::AddAssign` | `add_assign` | 加法赋值 |
| `-=` | `std::ops::SubAssign` | `sub_assign` | 减法赋值 |
| `*=` | `std::ops::MulAssign` | `mul_assign` | 乘法赋值 |
| `/=` | `std::ops::DivAssign` | `div_assign` | 除法赋值 |
| `%=` | `std::ops::RemAssign` | `rem_assign` | 取模赋值 |

## `AddAssign` Trait 详解

我们以 `AddAssign`（`+=`）为例，其他 Trait 的模式完全相同。

### Trait 定义

```rust
pub trait AddAssign<Rhs = Self> {
    fn add_assign(&mut self, rhs: Rhs);
}
```

*   **`&mut self`**: 方法的第一个参数是可变借用。这是因为复合赋值运算符会**直接修改**左侧的操作数，而不是像 `Add` 那样返回一个新的值。
*   **`Rhs`**: 右侧操作数的类型，默认为 `Self`。
*   **无返回值**: `add_assign` 不返回任何值（即返回单元类型 `()`）。

### 示例：Point 的 `+=` 运算

假设我们要实现 `p1 += p2`，将 `p2` 的坐标加到 `p1` 上。

```rust
use std::ops::AddAssign;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl AddAssign for Point {
    fn add_assign(&mut self, other: Point) {
        self.x += other.x;
        self.y += other.y;
    }
}

fn main() {
    let mut p1 = Point { x: 1, y: 0 };
    let p2 = Point { x: 2, y: 3 };

    p1 += p2; // 调用 p1.add_assign(p2)

    println!("{:?}", p1); // Point { x: 3, y: 3 }
}
```

### 示例：与不同类型进行运算

我们可以利用泛型 `Rhs` 实现不同类型的混合赋值。例如，让 `Point` 可以直接加上一个整数标量 `p1 += 5`。

```rust
impl AddAssign<i32> for Point {
    fn add_assign(&mut self, rhs: i32) {
        self.x += rhs;
        self.y += rhs;
    }
}

fn main() {
    let mut p = Point { x: 1, y: 1 };
    
    p += 10;
    
    println!("{:?}", p); // Point { x: 11, y: 11 }
}
```

## 注意事项

1.  **独立性**: 实现 `Add` Trait 不会自动实现 `AddAssign`。如果你希望你的类型既支持 `+` 也支持 `+=`，你需要分别实现这两个 Trait。
2.  **可变性**: 使用复合赋值运算符时，左侧的变量必须是声明为 `mut` 的。