# 有序比较

通过 `PartialOrd` 和 `Ord` 特型重载 `<`、`>`、`<=`、`>=` 运算符。

## 1. 核心概念

### Ordering 枚举

比较结果用三值表示：

```rust
pub enum Ordering {
    Less,    // 小于
    Equal,   // 等于
    Greater, // 大于
}
```

### 运算符映射

| 表达式 | 等价调用 |
| --- | --- |
| `a < b` | `a.partial_cmp(&b) == Some(Ordering::Less)` |
| `a > b` | `a.partial_cmp(&b) == Some(Ordering::Greater)` |
| `a <= b` | `matches!(a.partial_cmp(&b), Some(Less \| Equal))` |
| `a >= b` | `matches!(a.partial_cmp(&b), Some(Greater \| Equal))` |

### PartialOrd vs Ord

| 特性 | `PartialOrd` | `Ord` |
| --- | --- | --- |
| 返回类型 | `Option<Ordering>` | `Ordering` |
| 前置条件 | `PartialEq` | `Eq + PartialOrd` |
| 全序性 | 不保证（可能无法比较） | 任意两值必可比较 |
| 典型例外 | `f32`/`f64`（`NaN` 无法比较） | 无 |

### 特型签名

```rust
pub trait PartialOrd<Rhs = Self>: PartialEq<Rhs> {
    fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;

    // 默认实现，通常无需重写
    fn lt(&self, other: &Rhs) -> bool { ... }
    fn le(&self, other: &Rhs) -> bool { ... }
    fn gt(&self, other: &Rhs) -> bool { ... }
    fn ge(&self, other: &Rhs) -> bool { ... }
}

pub trait Ord: Eq + PartialOrd {
    fn cmp(&self, other: &Self) -> Ordering;

    // 默认实现
    fn max(self, other: Self) -> Self { ... }
    fn min(self, other: Self) -> Self { ... }
    fn clamp(self, min: Self, max: Self) -> Self { ... }
}
```

## 2. 实现方式

### 自动派生（推荐）

```rust
#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
struct Version {
    major: u32,
    minor: u32,
    patch: u32,
}

let v1 = Version { major: 1, minor: 2, patch: 0 };
let v2 = Version { major: 1, minor: 3, patch: 0 };
assert!(v1 < v2);  // 按字段声明顺序逐一比较
```

派生规则：按字段声明顺序进行字典序比较。

### 手动实现

需要自定义比较逻辑时：

```rust
use std::cmp::Ordering;

struct Task {
    priority: u8,
    name: String,
}

impl PartialEq for Task {
    fn eq(&self, other: &Self) -> bool {
        self.priority == other.priority
    }
}

impl Eq for Task {}

impl PartialOrd for Task {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))  // 委托给 Ord
    }
}

impl Ord for Task {
    fn cmp(&self, other: &Self) -> Ordering {
        other.priority.cmp(&self.priority)  // 高优先级排前面
    }
}
```

**实现顺序**：`PartialEq` → `Eq` → `PartialOrd` → `Ord`

## 3. 浮点数的特殊性

`f32`/`f64` 只实现 `PartialOrd`，因为 `NaN` 无法比较：

```rust
let nan = f64::NAN;
assert_eq!(nan.partial_cmp(&1.0), None);  // 无法比较
assert!(!(nan < 1.0));   // false
assert!(!(nan >= 1.0));  // false
```

**后果**：浮点数切片不能直接调用 `.sort()`。

**解决方案**：

```rust
let mut floats = vec![3.0, 1.0, f64::NAN, 2.0];

// 方案 1：partial_cmp + unwrap_or
floats.sort_by(|a, b| a.partial_cmp(b).unwrap_or(Ordering::Equal));

// 方案 2：total_cmp（Rust 1.62+，推荐）
floats.sort_by(f64::total_cmp);
```

## 4. 实用方法

### Ord 提供的便捷方法

```rust
let x = 5;

assert_eq!(x.max(3), 5);
assert_eq!(x.min(3), 3);

// clamp：限制在范围内
assert_eq!(x.clamp(0, 3), 3);   // 超出上限
assert_eq!(x.clamp(6, 10), 6);  // 低于下限
assert_eq!(x.clamp(0, 10), 5);  // 在范围内
```

### 反转比较顺序

```rust
use std::cmp::Reverse;

let mut nums = vec![3, 1, 4, 1, 5];
nums.sort();                         // 升序：[1, 1, 3, 4, 5]
nums.sort_by_key(|&x| Reverse(x));   // 降序：[5, 4, 3, 1, 1]
```

## 5. 使用场景

| 场景 | 要求 |
| --- | --- |
| 简单比较 `<`/`>` | `PartialOrd` |
| `Vec::sort()` | `Ord` |
| `BTreeMap`/`BTreeSet` 键 | `Ord` |
| `BinaryHeap` 元素 | `Ord` |
| `Iterator::max()`/`min()` | `Ord` |

## 6. 常见陷阱

### 派生顺序决定比较顺序

```rust
#[derive(PartialOrd, Ord, PartialEq, Eq)]
struct Person {
    age: u32,     // 先比较 age
    name: String, // age 相同才比较 name
}

// 想先按 name 排序？调整字段顺序或手动实现
```

### 包含浮点数无法派生 Ord

```rust
#[derive(PartialOrd)]
struct Data { value: f64 }  // ✅ 可以

// #[derive(Ord)]
// struct Data { value: f64 }  // 错误！f64 未实现 Ord
```

### 一致性要求

`PartialOrd` 和 `PartialEq` 必须保持一致：

```rust
// partial_cmp 返回 Some(Equal) ⟺ eq 返回 true
```

## 总结

- `PartialOrd` 重载比较运算符，返回 `Option<Ordering>`
- `Ord` 表示全序，额外提供 `max`/`min`/`clamp`
- 浮点数因 `NaN` 只有 `PartialOrd`，排序用 `sort_by` + `total_cmp`
- 集合类型（`BTreeMap`/`BinaryHeap`）和 `sort()` 要求 `Ord`
- 优先使用 `#[derive]`，派生按字段声明顺序比较
