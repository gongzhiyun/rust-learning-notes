# 有序比较

通过 `PartialOrd` 和 `Ord` trait 重载 `<`、`>`、`<=`、`>=` 运算符。

## 1. 核心概念

### Ordering 枚举

比较结果用三值表示：

```rust
pub enum Ordering {
    Less,    // 小于
    Equal,   // 等于
    Greater, // 大于
}
```

### 运算符映射

当你写 `a < b` 时，Rust 实际调用的是 `partial_cmp` 方法：

```rust
// 你写的代码
if a < b { ... }

// 编译器转换为
if a.partial_cmp(&b) == Some(Ordering::Less) { ... }
```

完整映射：

| 运算符 | 实际调用 | 返回 `true` 的条件 |
| --- | --- | --- |
| `a < b` | `a.partial_cmp(&b)` | 结果是 `Some(Less)` |
| `a > b` | `a.partial_cmp(&b)` | 结果是 `Some(Greater)` |
| `a <= b` | `a.partial_cmp(&b)` | 结果是 `Some(Less)` 或 `Some(Equal)` |
| `a >= b` | `a.partial_cmp(&b)` | 结果是 `Some(Greater)` 或 `Some(Equal)` |

**注意**：如果 `partial_cmp` 返回 `None`（无法比较），所有比较运算符都返回 `false`。

### 全序 vs 偏序

**全序**：任意两个值都能比较出大小，结果必是「大于/等于/小于」之一。

```rust
// 整数是全序：任意两个整数都能比较
let a = 3;
let b = 5;
assert!(a < b);  // 一定能得出结果
```

**偏序**：某些值之间可能无法比较。

```rust
// 浮点数是偏序：NaN 和任何数都无法比较
let nan = f64::NAN;
assert!(!(nan < 1.0));   // false
assert!(!(nan >= 1.0));  // false
assert!(!(nan == nan));  // false，连自己都不等于自己
```

### PartialOrd vs Ord

| 特性 | `PartialOrd` | `Ord` |
| --- | --- | --- |
| 返回类型 | `Option<Ordering>` | `Ordering` |
| 前置 trait | `PartialEq` | `Eq + PartialOrd` |
| 全序性 | 偏序（可能无法比较，返回 `None`） | 全序（任意两值必可比较） |
| 典型例外 | `f32`/`f64`（`NaN` 无法比较） | 无 |

**前置 trait 的含义**：

```rust
// PartialOrd 要求先实现 PartialEq
pub trait PartialOrd: PartialEq { ... }

// Ord 要求先实现 Eq 和 PartialOrd
pub trait Ord: Eq + PartialOrd { ... }
```

为什么有这个要求？因为「大小比较」依赖「相等比较」：

- 要判断 `a < b`，首先得能判断 `a == b`
- `Ord` 保证全序，所以需要 `Eq`（自反性：`a == a`）
- `PartialOrd` 允许偏序，所以只需要 `PartialEq`

**实现顺序**：`PartialEq` → `Eq` → `PartialOrd` → `Ord`

**关键区别**：`PartialOrd::partial_cmp` 返回 `Option`，无法比较时返回 `None`；`Ord::cmp` 直接返回 `Ordering`，保证一定有结果。

### Trait 签名

```rust
pub trait PartialOrd<Rhs = Self>: PartialEq<Rhs> {
    fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;

    // 默认实现，通常无需重写
    fn lt(&self, other: &Rhs) -> bool { ... }
    fn le(&self, other: &Rhs) -> bool { ... }
    fn gt(&self, other: &Rhs) -> bool { ... }
    fn ge(&self, other: &Rhs) -> bool { ... }
}

pub trait Ord: Eq + PartialOrd {
    fn cmp(&self, other: &Self) -> Ordering;

    // 默认实现
    fn max(self, other: Self) -> Self { ... }
    fn min(self, other: Self) -> Self { ... }
    fn clamp(self, min: Self, max: Self) -> Self { ... }
}
```

## 2. 实现方式

### 自动派生（推荐）

```rust
#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
struct Version {
    major: u32,
    minor: u32,
    patch: u32,
}

let v1 = Version { major: 1, minor: 2, patch: 0 };
let v2 = Version { major: 1, minor: 3, patch: 0 };
assert!(v1 < v2);  // 按字段声明顺序逐一比较
```

派生规则：按字段声明顺序进行字典序比较。

### 手动实现

需要自定义比较逻辑时：

```rust
use std::cmp::Ordering;

struct Task {
    priority: u8,
    name: String,
}

impl PartialEq for Task {
    fn eq(&self, other: &Self) -> bool {
        self.priority == other.priority
    }
}

impl Eq for Task {}

impl PartialOrd for Task {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))  // 委托给 Ord
    }
}

impl Ord for Task {
    fn cmp(&self, other: &Self) -> Ordering {
        other.priority.cmp(&self.priority)  // 高优先级排前面
    }
}
```

**实现顺序**：`PartialEq` → `Eq` → `PartialOrd` → `Ord`

## 3. 浮点数的特殊性

`f32`/`f64` 只实现 `PartialOrd`，因为 `NaN` 无法比较：

```rust
let nan = f64::NAN;
assert_eq!(nan.partial_cmp(&1.0), None);  // 无法比较
assert!(!(nan < 1.0));   // false
assert!(!(nan >= 1.0));  // false
```

**后果**：浮点数切片不能直接调用 `.sort()`。

**解决方案**：

```rust
let mut floats = vec![3.0, 1.0, f64::NAN, 2.0];

// 方案 1：partial_cmp + unwrap_or
floats.sort_by(|a, b| a.partial_cmp(b).unwrap_or(Ordering::Equal));

// 方案 2：total_cmp（Rust 1.62+，推荐）
floats.sort_by(f64::total_cmp);
```

## 4. 实用方法

### Ord 提供的便捷方法

```rust
let x = 5;

assert_eq!(x.max(3), 5);
assert_eq!(x.min(3), 3);

// clamp：限制在范围内
assert_eq!(x.clamp(0, 3), 3);   // 超出上限
assert_eq!(x.clamp(6, 10), 6);  // 低于下限
assert_eq!(x.clamp(0, 10), 5);  // 在范围内
```

### 反转比较顺序

```rust
use std::cmp::Reverse;

let mut nums = vec![3, 1, 4, 1, 5];
nums.sort();                         // 升序：[1, 1, 3, 4, 5]
nums.sort_by_key(|&x| Reverse(x));   // 降序：[5, 4, 3, 1, 1]
```

## 5. 使用场景

| 场景 | 要求 |
| --- | --- |
| 简单比较 `<`/`>` | `PartialOrd` |
| `Vec::sort()` | `Ord` |
| `BTreeMap`/`BTreeSet` 键 | `Ord` |
| `BinaryHeap` 元素 | `Ord` |
| `Iterator::max()`/`min()` | `Ord` |

## 6. 常见陷阱

### 字段顺序决定比较顺序

派生 `PartialOrd`/`Ord` 时，按字段声明顺序逐一比较（字典序）：

```rust
#[derive(PartialEq, Eq, PartialOrd, Ord)]
struct Person {
    age: u32,     // 第一个字段，优先比较
    name: String, // 第二个字段，age 相同时才比较
}

let alice = Person { age: 30, name: "Alice".into() };
let bob = Person { age: 25, name: "Bob".into() };
let charlie = Person { age: 30, name: "Charlie".into() };

// 先比较 age
assert!(bob < alice);     // 25 < 30，不看 name

// age 相同时才比较 name
assert!(alice < charlie); // age 都是 30，比较 "Alice" < "Charlie"
```

**想先按 name 排序？** 两种方案：

```rust
// 方案 1：调整字段顺序
#[derive(PartialEq, Eq, PartialOrd, Ord)]
struct Person {
    name: String, // 现在先比较 name
    age: u32,
}

// 方案 2：手动实现 Ord
```

### 包含浮点数无法派生 Ord

```rust
#[derive(PartialOrd)]
struct Data { value: f64 }  // ✅ 可以

// #[derive(Ord)]
// struct Data { value: f64 }  // 错误！f64 未实现 Ord
```

### 一致性要求

`PartialOrd` 和 `PartialEq` 的结果必须一致：

```rust
// 规则：partial_cmp 返回 Equal 时，eq 必须返回 true
// a.partial_cmp(&b) == Some(Equal)  ⟺  a == b
```

**错误示例**：

```rust
struct Bad(i32);

impl PartialEq for Bad {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl PartialOrd for Bad {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        // 错误！忽略了相等的情况，总是返回 Less
        Some(Ordering::Less)
    }
}

let a = Bad(5);
let b = Bad(5);
// a == b 返回 true
// a.partial_cmp(&b) 返回 Some(Less)，不是 Some(Equal)
// 这会导致排序等操作出现未定义行为
```

**正确做法**：使用 `#[derive]` 或确保手动实现时两者逻辑一致。

## 总结

- `PartialOrd` 重载比较运算符，返回 `Option<Ordering>`
- `Ord` 表示全序，额外提供 `max`/`min`/`clamp`
- 浮点数因 `NaN` 只有 `PartialOrd`，排序用 `sort_by` + `total_cmp`
- 集合类型（`BTreeMap`/`BinaryHeap`）和 `sort()` 要求 `Ord`
- 优先使用 `#[derive]`，派生按字段声明顺序比较
