# 二元运算符重载

二元运算符是作用于两个操作数的运算符。在 Rust 中，许多二元运算符可以通过实现 `std::ops` 模块中的 Trait 来进行重载。

## 常用二元运算符

| 运算符 | Trait | 方法名 | 说明 |
| :--- | :--- | :--- | :--- |
| `+` | `std::ops::Add` | `add` | 加法 |
| `-` | `std::ops::Sub` | `sub` | 减法 |
| `*` | `std::ops::Mul` | `mul` | 乘法 |
| `/` | `std::ops::Div` | `div` | 除法 |
| `%` | `std::ops::Rem` | `rem` | 取模 (余数) |

## 1. `Add` Trait (加法)

我们以 `Add` Trait 为例，其他二元运算符的使用方式与其非常相似。

### Trait 定义

```rust
pub trait Add<Rhs = Self> {
    type Output;
    fn add(self, rhs: Rhs) -> Self::Output;
}
```

*   **`Rhs` (Right Hand Side)**: 这是一个泛型参数，代表加号右侧操作数的类型。默认为 `Self`（即左右两侧类型相同）。
*   **`Output`**: 关联类型，指定运算结果的类型。

### 示例：实现 Point 加法

```rust
use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 0 };
    let p2 = Point { x: 2, y: 3 };
    
    // 等价于 p1.add(p2)
    let p3 = p1 + p2;
    
    println!("{:?}", p3); // Point { x: 3, y: 3 }
}
```

## 2. 处理所有权与引用

默认的 `add` 方法会获取 `self` 和 `rhs` 的所有权。如果希望在计算后仍然保留原值，可以为**引用类型**实现 Trait。

```rust
// 为 &Point 实现 Add
impl Add for &Point {
    type Output = Point;

    fn add(self, other: &Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 0 };
    let p2 = Point { x: 2, y: 3 };
    
    // 这里使用的是引用，p1 和 p2 不会被消耗
    let p3 = &p1 + &p2;
    
    println!("p1: {:?}, p2: {:?}, p3: {:?}", p1, p2, p3);
}
```

## 3. 异构类型运算 (Rhs)

我们可以利用泛型 `Rhs` 来实现不同类型之间的运算。例如，允许 `Point` 加上一个 `i32` 标量（给 x 和 y 都加上该值）。

```rust
impl Add<i32> for Point {
    type Output = Point;

    fn add(self, rhs: i32) -> Point {
        Point {
            x: self.x + rhs,
            y: self.y + rhs,
        }
    }
}

fn main() {
    let p = Point { x: 1, y: 1 };
    let p_new = p + 10; 
    
    println!("{:?}", p_new); // Point { x: 11, y: 11 }
}
```