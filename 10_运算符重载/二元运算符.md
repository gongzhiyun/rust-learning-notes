# 二元运算符重载

二元运算符作用于两个操作数。Rust 通过 `std::ops` 模块中的 trait 实现重载。

## 核心概念

### 算术运算符

| 运算符 | Trait | 方法 |
| --- | --- | --- |
| `a + b` | `Add<Rhs>` | `add(self, rhs)` |
| `a - b` | `Sub<Rhs>` | `sub(self, rhs)` |
| `a * b` | `Mul<Rhs>` | `mul(self, rhs)` |
| `a / b` | `Div<Rhs>` | `div(self, rhs)` |
| `a % b` | `Rem<Rhs>` | `rem(self, rhs)` |

### 位运算符

| 运算符 | Trait | 方法 |
| --- | --- | --- |
| `a & b` | `BitAnd<Rhs>` | `bitand(self, rhs)` |
| `a \| b` | `BitOr<Rhs>` | `bitor(self, rhs)` |
| `a ^ b` | `BitXor<Rhs>` | `bitxor(self, rhs)` |
| `a << b` | `Shl<Rhs>` | `shl(self, rhs)` |
| `a >> b` | `Shr<Rhs>` | `shr(self, rhs)` |

### Trait 签名

所有二元运算符 trait 结构相同，以 `Add` 为例：

```rust
pub trait Add<Rhs = Self> {
    type Output;
    fn add(self, rhs: Rhs) -> Self::Output;
}
```

- `Rhs`：右操作数类型，默认为 `Self`
- `Output`：运算结果类型

## 基本实现

```rust
use std::ops::Add;

#[derive(Debug, PartialEq, Clone, Copy)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let p3 = p1 + p2; // 调用 p1.add(p2)
    assert_eq!(p3, Point { x: 4, y: 6 });
}
```

## 异构类型运算

利用 `Rhs` 泛型参数实现不同类型间的运算：

```rust
use std::ops::Mul;

impl Mul<i32> for Point {
    type Output = Point;

    fn mul(self, scalar: i32) -> Point {
        Point {
            x: self.x * scalar,
            y: self.y * scalar,
        }
    }
}

fn main() {
    let p = Point { x: 2, y: 3 };
    let scaled = p * 10; // Point * i32
    assert_eq!(scaled, Point { x: 20, y: 30 });
}
```

## 为引用实现

默认方法消耗 `self` 和 `rhs`。为引用实现可保留原值：

```rust
use std::ops::Add;

impl Add for &Point {
    type Output = Point;

    fn add(self, other: &Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let p3 = &p1 + &p2; // p1, p2 仍可用
    println!("{:?} + {:?} = {:?}", p1, p2, p3);
}
```

## 完整实现模式

为了支持所有组合（值/引用），通常需要实现 4 种情况：

```rust
impl Add<Point> for Point { /* ... */ }
impl Add<&Point> for Point { /* ... */ }
impl Add<Point> for &Point { /* ... */ }
impl Add<&Point> for &Point { /* ... */ }
```

**简化方案**：让类型实现 `Copy`，只需实现值类型版本。

## 注意事项

### Output 类型灵活性

`Output` 不必与操作数类型相同：

```rust
use std::ops::Mul;

#[derive(Debug)]
struct Matrix2x3;

#[derive(Debug)]
struct Matrix3x2;

#[derive(Debug)]
struct Matrix2x2;

impl Mul<Matrix3x2> for Matrix2x3 {
    type Output = Matrix2x2; // 2x3 * 3x2 = 2x2
    
    fn mul(self, _rhs: Matrix3x2) -> Matrix2x2 {
        Matrix2x2
    }
}
```

### 运算符不可交换

`a + b` 调用 `a.add(b)`，若需要 `b + a`，需单独实现：

```rust
// Point + i32
impl Add<i32> for Point { /* ... */ }

// i32 + Point（需要额外实现）
impl Add<Point> for i32 {
    type Output = Point;
    
    fn add(self, p: Point) -> Point {
        Point { x: self + p.x, y: self + p.y }
    }
}
```

## 总结

- 二元运算符通过 `std::ops` 中的 trait 重载
- `Rhs` 泛型参数支持异构类型运算
- `Output` 关联类型决定返回值类型
- 为引用实现可避免所有权转移
- 运算符不自动交换，需双向实现
