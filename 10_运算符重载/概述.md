# 运算符重载

通过实现 `std::ops` 模块中的特型，让自定义类型支持 `+`、`-`、`*` 等运算符。

## 核心要点

表达式 `a + b` 是 `a.add(b)` 的语法糖，重载运算符 = 实现对应特型。

```rust
use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point { x: i32, y: i32 }

impl Add for Point {
    type Output = Point;  // 运算结果类型

    fn add(self, rhs: Point) -> Point {
        Point { x: self.x + rhs.x, y: self.y + rhs.y }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    assert_eq!(p1 + p2, Point { x: 4, y: 6 });
}
```

## 运算符特型速查

| 类别 | 运算符 | 特型 | 方法 |
| --- | --- | --- | --- |
| 算术 | `+` `-` `*` `/` `%` | `Add` `Sub` `Mul` `Div` `Rem` | `add` `sub` `mul` `div` `rem` |
| 一元 | `-x` `!x` | `Neg` `Not` | `neg` `not` |
| 复合赋值 | `+=` `-=` `*=` `/=` `%=` | `AddAssign` `SubAssign` ... | `add_assign` ... |
| 比较 | `==` `!=` | `PartialEq` `Eq` | `eq` `ne` |
| 排序 | `<` `>` `<=` `>=` | `PartialOrd` `Ord` | `partial_cmp` `cmp` |
| 位运算 | `&` `\|` `^` `<<` `>>` | `BitAnd` `BitOr` `BitXor` `Shl` `Shr` | 同名小写 |
| 索引 | `[]` | `Index` `IndexMut` | `index` `index_mut` |
| 解引用 | `*` | `Deref` `DerefMut` | `deref` `deref_mut` |

## 特型签名模式

大多数运算符特型遵循相同模式：

```rust
pub trait Add<Rhs = Self> {      // Rhs 默认为 Self，支持异构运算
    type Output;                  // 关联类型，定义结果类型
    fn add(self, rhs: Rhs) -> Self::Output;
}
```

- **Rhs 泛型**：允许 `Point + i32` 这样的异构运算
- **Output 关联类型**：结果类型可以不同于操作数类型

## 注意事项

| 限制 | 说明 |
| --- | --- |
| 不能创建新运算符 | 只能重载预定义的运算符，不能发明 `~=` 或 `+++` |
| 孤儿规则 | 特型或类型至少有一个在当前 crate 定义 |
| 优先级不变 | 重载不改变运算符优先级和结合性 |

不可重载的运算符：

- `.` 成员访问
- `&&` `||` 短路逻辑运算（无法用函数调用模拟短路）
- `..` 范围运算符（通过 `Range` 结构体实现）

## 总结

1. 运算符重载 = 实现 `std::ops` 中的特型
2. 特型签名：`Rhs` 泛型支持异构运算，`Output` 关联类型定义结果
3. 受孤儿规则约束，不能为外部类型实现外部特型
