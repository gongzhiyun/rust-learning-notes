# Rust 运算符重载 (Operator Overloading)

Rust 允许通过实现特定的 trait 来自定义运算符（如 `+`, `*`, `-` 等）在自定义类型上的行为。这被称为**运算符重载**。

所有的运算符 trait 都定义在标准库的 `std::ops` 模块中。

## 1. 核心概念

在 Rust 中，表达式 `a + b` 实际上是方法调用 `a.add(b)` 的语法糖。因此，重载运算符本质上就是实现对应的 Trait。

例如，要重载 `+` 运算符，你需要为你的类型实现 `std::ops::Add` trait：

```rust
pub trait Add<Rhs = Self> {
    type Output;
    fn add(self, rhs: Rhs) -> Self::Output;
}
```

*   **Rhs (Right Hand Side)**: 泛型参数，默认默认为 `Self`。这允许你定义异构类型的运算（例如 `Point + i32`）。
*   **Output**: 关联类型，定义了运算结果的类型。

## 2. 常见的运算符 Trait

以下是一些常用的运算符及其对应的 Trait：

| 运算符 | Trait | 方法名 | 说明 |
| :--- | :--- | :--- | :--- |
| `+` | `std::ops::Add` | `add` | 加法 |
| `-` | `std::ops::Sub` | `sub` | 减法 |
| `*` | `std::ops::Mul` | `mul` | 乘法 |
| `/` | `std::ops::Div` | `div` | 除法 |
| `%` | `std::ops::Rem` | `rem` | 取模 |
| `-` (前缀) | `std::ops::Neg` | `neg` | 负号 (一元) |
| `!` | `std::ops::Not` | `not` | 逻辑非/按位非 (一元) |
| `+=` | `std::ops::AddAssign` | `add_assign` | 复合赋值加法 |
| `*` (解引用) | `std::ops::Deref` | `deref` | 智能指针解引用 |
| `[]` | `std::ops::Index` | `index` | 不可变索引访问 |

## 3. 基本示例

为一个 `Point` 结构体实现加法：

```rust
use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 0 };
    let p2 = Point { x: 2, y: 3 };
    
    // 使用运算符
    let p3 = p1 + p2; 
    
    assert_eq!(p3, Point { x: 3, y: 3 });
}
```

## 4. 限制与规则

1.  **无法创建新运算符**：你只能重载 Rust 语言预定义的运算符，不能发明新的符号（如 `~=` 或 `+++`）。
2.  **孤儿规则 (Orphan Rule)**：你不能为外部类型实现外部 Trait。也就是说，实现 Trait 时，Trait 或 类型至少有一个是在当前 crate 中定义的。
    *   例如：不能为 `i32` 实现 `Add`（因为 `i32` 和 `Add` 都在标准库定义）。
3.  **优先级不变**：重载不会改变运算符的优先级和结合性。
4.  **特殊运算符不可重载**：
    *   成员访问 `.`
    *   函数调用 `()` (但在 Nightly 版本中有 `Fn`, `FnMut`, `FnOnce` trait)
    *   逻辑运算符 `&&` 和 `||` (因为它们具有短路求值特性，无法通过简单的函数调用模拟)
    *   范围运算符 `..` 等（通过 `Range` 系列结构体实现，通常不重载）