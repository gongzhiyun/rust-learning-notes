# 一元运算符

在 Rust 中，一元运算符（Unary Operators）是指只作用于一个操作数的运算符。主要有两个可以重载的一元运算符：

1.  `-` (取负)：对应 `std::ops::Neg` trait。
2.  `!` (取反)：对应 `std::ops::Not` trait。

*(注：`*` 解引用运算符也是一元运算符，对应 `std::ops::Deref` trait，通常在智能指针章节详细讨论)*

## 1. `std::ops::Neg` (取负)

`Neg` trait 允许你重载 `-` 运算符。它通常用于数值类型，表示取相反数。

### 定义

```rust
pub trait Neg {
    type Output;

    fn neg(self) -> Self::Output;
}
```

### 示例：为复数结构体实现取负

假设我们有一个表示复数的结构体 `Complex`，我们可以为它实现 `-` 运算符，使其重新生成一个新的 `Complex`，其实部和虚部都是原值的相反数。

```rust
use std::ops::Neg;

#[derive(Debug, PartialEq)]
struct Complex {
    re: i32,
    im: i32,
}

impl Neg for Complex {
    type Output = Complex;

    fn neg(self) -> Self::Output {
        Complex {
            re: -self.re,
            im: -self.im,
        }
    }
}

fn main() {
    let c = Complex { re: 1, im: 2 };
    let neg_c = -c; // 调用 c.neg()

    assert_eq!(neg_c, Complex { re: -1, im: -2 });
    println!("Original: -1-2i, Result: {:?}", neg_c);
}
```

## 2. `std::ops::Not` (取反)

`Not` trait 允许你重载 `!` 运算符。它通常用于布尔值（逻辑非）或整数（按位取反）。

### 定义

```rust
pub trait Not {
    type Output;

    fn not(self) -> Self::Output;
}
```

### 示例：为自定义类型实现取反

假设我们有一个简单的枚举表示开关状态，我们可以为它实现 `!` 运算符来切换状态。

```rust
use std::ops::Not;

#[derive(Debug, PartialEq)]
enum SwitchState {
    On,
    Off,
}

impl Not for SwitchState {
    type Output = SwitchState;

    fn not(self) -> Self::Output {
        match self {
            SwitchState::On => SwitchState::Off,
            SwitchState::Off => SwitchState::On,
        }
    }
}

fn main() {
    let light = SwitchState::On;
    let toggled = !light; // 调用 light.not()

    assert_eq!(toggled, SwitchState::Off);
    println!("State after toggle: {:?}", toggled);
}
```

## 注意事项

1.  **所有权 (Ownership)**: `neg` 和 `not` 方法都获取 `self` 的所有权。如果你希望在运算后保留原值，可以为引用的类型实现这些 trait（例如 `impl Neg for &Complex`）。
2.  **关联类型 `Output`**: 你必须指定操作返回的类型。通常情况下，返回类型与输入类型相同，但这并非强制。

### 为引用实现一元运算符

如果你不想消耗操作数的所有权，可以为引用实现 Trait：

```rust
use std::ops::Neg;

#[derive(Debug, PartialEq)]
struct Vector2 {
    x: f64,
    y: f64,
}

// 为 &Vector2 实现 Neg，返回一个新的 Vector2
impl Neg for &Vector2 {
    type Output = Vector2;

    fn neg(self) -> Vector2 {
        Vector2 {
            x: -self.x,
            y: -self.y,
        }
    }
}

fn main() {
    let v = Vector2 { x: 3.0, y: 4.0 };
    let neg_v = -&v; // 注意这里是对引用取负

    println!("Original: {:?}", v); // v 仍然可用
    println!("Negative: {:?}", neg_v);
}
```
