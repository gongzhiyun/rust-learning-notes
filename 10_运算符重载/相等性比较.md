# 相等性比较

通过 `PartialEq` 和 `Eq` trait 重载 `==` 和 `!=` 运算符。

## 1. 核心概念

### 运算符映射

| 表达式 | 等价调用 |
| --- | --- |
| `a == b` | `a.eq(&b)` |
| `a != b` | `!a.eq(&b)` |

### 等价关系的三个性质

理解 `PartialEq` 和 `Eq` 的区别，先了解「相等」应满足的数学性质：

| 性质 | 含义 | 例子 |
| --- | --- | --- |
| 自反性 | 自己等于自己 | `a == a` 恒为真 |
| 对称性 | 顺序无关 | `a == b` 则 `b == a` |
| 传递性 | 可传递 | `a == b` 且 `b == c`，则 `a == c` |

浮点数的 `NaN` 违反自反性：

```rust
let nan = f64::NAN;
assert!(nan != nan);  // NaN 不等于自身！
```

### PartialEq vs Eq

| 特性 | `PartialEq` | `Eq` |
| --- | --- | --- |
| 类型 | 普通 trait | 标记 trait（无方法） |
| 数学性质 | 对称性 + 传递性 | 对称性 + 传递性 + **自反性** |
| 自反性 | 不保证 `a == a` | 保证 `a == a` 恒为真 |
| 典型例外 | `f32`/`f64`（`NaN != NaN`） | 无 |

简单理解：`Eq` = `PartialEq` + 自反性保证。

**关键点**：`Eq` 是标记 trait，没有任何方法。它不会在运行时检查自反性，而是程序员的「承诺」——告诉编译器和其他开发者：「我保证这个类型的 `==` 满足自反性」。编译器信任这个承诺，不做验证。

这就是为什么 `f64` 不实现 `Eq`：浮点数的 `NaN != NaN`，无法做出这个承诺。

### Trait 签名

```rust
pub trait PartialEq<Rhs = Self> {
    fn eq(&self, other: &Rhs) -> bool;

    fn ne(&self, other: &Rhs) -> bool {
        !self.eq(other)  // 默认实现，通常无需重写
    }
}

pub trait Eq: PartialEq {}  // 标记 trait，无额外方法
```

## 2. 实现方式

### 自动派生（推荐）

```rust
#[derive(Debug, PartialEq, Eq)]
struct Point { x: i32, y: i32 }

let p1 = Point { x: 1, y: 2 };
let p2 = Point { x: 1, y: 2 };
assert_eq!(p1, p2);  // 所有字段逐一比较
```

### 手动实现

派生会比较所有字段，手动实现可以自定义比较逻辑：

```rust
struct Book {
    isbn: u32,       // 唯一标识
    format: String,  // 精装/平装，不影响「同一本书」的判断
}

impl PartialEq for Book {
    fn eq(&self, other: &Self) -> bool {
        self.isbn == other.isbn  // 只比较 ISBN，忽略 format
    }
}

impl Eq for Book {}  // 标记 trait，空实现
```

效果：

```rust
let hardcover = Book { isbn: 123, format: "精装".into() };
let paperback = Book { isbn: 123, format: "平装".into() };

assert!(hardcover == paperback);  // ✅ ISBN 相同，视为同一本书
```

### 分别实现 == 和 !=

`!=` 默认是 `!eq()`，通常无需重写。极少数场景可能需要独立逻辑：

```rust
struct ApproxFloat(f64);

impl PartialEq for ApproxFloat {
    fn eq(&self, other: &Self) -> bool {
        (self.0 - other.0).abs() < 0.001  // 差值 < 0.001 视为相等
    }

    fn ne(&self, other: &Self) -> bool {
        (self.0 - other.0).abs() >= 0.01  // 差值 >= 0.01 才视为不等
    }
}
```

**注意**：这会导致 `!(a == b)` 和 `a != b` 结果不一致，应谨慎使用。

## 3. 异构类型比较

利用 `Rhs` 泛型参数实现不同类型间的比较：

```rust
struct Meter(u32);
struct Centimeter(u32);

impl PartialEq<Centimeter> for Meter {
    fn eq(&self, other: &Centimeter) -> bool {
        self.0 * 100 == other.0
    }
}

// 为保证对称性，反向也需实现
impl PartialEq<Meter> for Centimeter {
    fn eq(&self, other: &Meter) -> bool {
        self.0 == other.0 * 100
    }
}

let m = Meter(1);
let cm = Centimeter(100);
assert!(m == cm && cm == m);  // 双向比较
```

## 4. 浮点数的特殊性

`f32`/`f64` 只实现 `PartialEq`，因为 `NaN` 违反自反性：

```rust
let nan = f64::NAN;
assert!(nan != nan);  // NaN 不等于自身！
```

**后果**：浮点数不能作为 `HashMap` 键（要求 `Eq + Hash`）。

**解决方案**：使用 `ordered-float` crate 或自定义包装类型。

## 5. 使用场景

### 只需 PartialEq

大多数场景只需要 `PartialEq`：

```rust
fn find<T: PartialEq>(slice: &[T], target: &T) -> Option<usize> {
    slice.iter().position(|x| x == target)
}
```

| 场景 | 说明 |
| --- | --- |
| `==`/`!=` 运算符 | 基本比较 |
| `Vec::contains()` | 查找元素 |
| `Iterator::find()` | 迭代器查找 |
| `assert_eq!` 宏 | 测试断言 |
| 模式匹配守卫 | `if x == y` |

### 必须 Eq

当类型作为哈希集合的键时，必须实现 `Eq`：

```rust
use std::collections::HashMap;

#[derive(PartialEq, Eq, Hash)]
struct UserId(u64);

let mut map: HashMap<UserId, String> = HashMap::new();
map.insert(UserId(1), "Alice".into());
```

| 场景 | 要求 | 原因 |
| --- | --- | --- |
| `HashMap`/`HashSet` 键 | `Eq + Hash` | 查找时需保证 `a == a` |
| `BTreeMap`/`BTreeSet` 键 | `Ord`（隐含 `Eq`） | 有序集合 |

### 为什么 HashMap 需要 Eq？

```rust
// 假设 HashMap 允许 PartialEq
let mut map = HashMap::new();
map.insert(f64::NAN, "value");

// 查找时：NAN != NAN，永远找不到！
map.get(&f64::NAN);  // 返回 None，即使刚插入
```

`Eq` 的自反性保证 `a == a`，确保插入的键总能被找到。

## 6. 常见陷阱

### 包含浮点数无法派生 Eq

```rust
#[derive(PartialEq)]
struct Data { value: f64 }  // ✅ 可以

// #[derive(Eq)]
// struct Data { value: f64 }  // 错误！f64 未实现 Eq
```

### Hash 一致性要求

若同时实现 `PartialEq` 和 `Hash`，必须保证：

```rust
// 若 a == b，则 hash(a) == hash(b)
// 否则 HashMap 行为未定义
```

### 派生比较所有字段

```rust
#[derive(PartialEq)]
struct User {
    id: u64,
    cache: Vec<u8>,  // 也会参与比较！
}

// 若只想比较 id，需手动实现
```

## 总结

- `==`/`!=` 通过 `PartialEq` trait 重载
- `Eq` 是标记 trait，表示自反性（`a == a` 恒真）
- 浮点数因 `NaN` 只实现 `PartialEq`，不能作为 `HashMap` 键
- 异构比较需双向实现以保证对称性
- 优先使用 `#[derive(PartialEq, Eq)]`
