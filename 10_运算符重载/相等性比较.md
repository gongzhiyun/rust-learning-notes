# 相等性比较

通过 `PartialEq` 和 `Eq` trait 重载 `==` 和 `!=` 运算符，定义在 `std::cmp` 模块中。

## 核心概念

### 运算符映射

| 表达式 | 等价调用 |
| --- | --- |
| `a == b` | `a.eq(&b)` |
| `a != b` | `!a.eq(&b)` |

### PartialEq vs Eq

| 特性 | `PartialEq` | `Eq` |
| --- | --- | --- |
| 类型 | 普通 trait | 标记 trait（无方法） |
| 数学性质 | 对称性 + 传递性 | 对称性 + 传递性 + 自反性 |
| 自反性 | 不保证 `a == a` | 保证 `a == a` 总为真 |
| 典型例外 | `f32`/`f64`（`NaN != NaN`） | 无 |

### Trait 签名

```rust
pub trait PartialEq<Rhs: ?Sized = Self> {
    fn eq(&self, other: &Rhs) -> bool;

    fn ne(&self, other: &Rhs) -> bool {
        !self.eq(other)  // 默认实现，通常无需重写
    }
}

pub trait Eq: PartialEq<Self> { }  // 标记 trait，无额外方法
```

## 基本实现

### 自动派生（推荐）

```rust
#[derive(Debug, PartialEq, Eq)]
struct Point { x: i32, y: i32 }

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 1, y: 2 };
    assert_eq!(p1, p2);
}
```

### 手动实现

当需要自定义比较逻辑时：

```rust
struct Book {
    isbn: u32,
    format: String,  // 不参与比较
}

impl PartialEq for Book {
    fn eq(&self, other: &Self) -> bool {
        self.isbn == other.isbn  // 只比较 ISBN
    }
}

impl Eq for Book {}  // 标记 trait，空实现

fn main() {
    let b1 = Book { isbn: 123, format: "Hardcover".into() };
    let b2 = Book { isbn: 123, format: "Paperback".into() };
    assert!(b1 == b2);  // 格式不同但 ISBN 相同
}
```

## 异构类型比较

利用 `Rhs` 泛型参数实现不同类型间的比较：

```rust
struct Meter(u32);
struct Centimeter(u32);

impl PartialEq<Centimeter> for Meter {
    fn eq(&self, other: &Centimeter) -> bool {
        self.0 * 100 == other.0
    }
}

// 为保证对称性，反向也需实现
impl PartialEq<Meter> for Centimeter {
    fn eq(&self, other: &Meter) -> bool {
        self.0 == other.0 * 100
    }
}

fn main() {
    let m = Meter(1);
    let cm = Centimeter(100);
    assert!(m == cm);
    assert!(cm == m);
}
```

## 浮点数的特殊性

`f32`/`f64` 只实现 `PartialEq`，不实现 `Eq`：

```rust
let nan = f64::NAN;
assert!(nan != nan);  // NaN 不等于自身，违反自反性
```

**后果**：浮点数不能直接作为 `HashMap` 的键（要求 `Eq + Hash`）。

**解决方案**：使用 `ordered-float` crate 或自定义包装类型。

## 注意事项

### Eq 的使用场景

| 场景 | 是否需要 Eq |
| --- | --- |
| 简单比较 `==` | 只需 `PartialEq` |
| `HashMap` 键 | 必须 `Eq + Hash` |
| `BTreeMap` 键 | 必须 `Ord`（隐含 `Eq`） |
| 模式匹配 | 只需 `PartialEq` |

### 派生限制

```rust
#[derive(PartialEq)]       // 可以
struct Data { value: f64 }

// #[derive(Eq)]           // 错误！f64 未实现 Eq
// struct Data { value: f64 }
```

### 保持一致性

若同时实现 `PartialEq` 和 `Hash`，必须保证：

```rust
// 若 a == b，则 hash(a) == hash(b)
```

## 总结

- `==`/`!=` 通过 `PartialEq` trait 重载
- `Eq` 是标记 trait，表示自反性（`a == a` 恒真）
- 浮点数因 `NaN` 只实现 `PartialEq`
- `HashMap` 键要求 `Eq + Hash`
- 优先使用 `#[derive(PartialEq, Eq)]`
