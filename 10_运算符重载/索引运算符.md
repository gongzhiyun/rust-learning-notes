# 索引运算符重载

通过实现 `Index` 和 `IndexMut` trait，让自定义类型支持 `[]` 索引语法。

## 核心要点

`Index` 和 `IndexMut` 让自定义类型支持 `[]` 下标访问：

- `a[i]` 只读访问 → 调用 `Index::index(&a, i)`，返回 `&T`
- `a[i] = v` 可变访问 → 调用 `IndexMut::index_mut(&mut a, i)`，返回 `&mut T`

关键点：`a[i]` 实际是 `*a.index(i)` 的语法糖，编译器自动解引用。

```rust
use std::ops::Index;

struct Image {
    width: usize,
    pixels: Vec<u8>,  // 一维数组存储所有像素
}

// 为 Image 实现 Index trait，索引类型为 usize
impl Index<usize> for Image {
    type Output = [u8];  // 返回类型是切片（动态大小类型）

    // 按行号索引，返回该行所有像素的切片
    fn index(&self, row: usize) -> &[u8] {
        let start = row * self.width;  // 计算该行起始位置
        &self.pixels[start..start + self.width]  // 返回该行切片
    }
}

fn main() {
    let image = Image {
        width: 3,
        pixels: vec![1, 2, 3,   // 第 0 行
                     4, 5, 6,   // 第 1 行
                     7, 8, 9],  // 第 2 行
    };
    // image[1] 等价于 *image.index(1)
    assert_eq!(image[1], [4, 5, 6]);  // 获取第 1 行
}
```

## Trait 签名

### Index（只读索引）

```rust
pub trait Index<Idx> {
    type Output: ?Sized;           // ?Sized 表示可以是动态大小类型，如 [T] 或 str
    fn index(&self, index: Idx) -> &Self::Output;
}
```

### IndexMut（可变索引）

```rust
pub trait IndexMut<Idx>: Index<Idx> {
    fn index_mut(&mut self, index: Idx) -> &mut Self::Output;
}
```

关键点：

- `IndexMut` 继承自 `Index`，必须先实现 `Index`
- `?Sized` 约束允许 `Output` 是动态大小类型（如 `[T]` 切片、`str` 字符串切片），这些类型编译时大小未知，只能通过引用使用
- 方法返回引用，`a[i]` 会自动解引用

## 可变索引

实现 `IndexMut` 支持 `a[i] = value` 赋值：

```rust
use std::ops::{Index, IndexMut};

struct Image {
    width: usize,
    pixels: Vec<u8>,
}

impl Index<usize> for Image {
    type Output = [u8];
    fn index(&self, row: usize) -> &[u8] {
        let start = row * self.width;
        &self.pixels[start..start + self.width]
    }
}

impl IndexMut<usize> for Image {
    fn index_mut(&mut self, row: usize) -> &mut [u8] {
        let start = row * self.width;
        &mut self.pixels[start..start + self.width]
    }
}

fn main() {
    let mut image = Image {
        width: 3,
        pixels: vec![0; 9],
    };
    image[1][0] = 255;  // 修改第二行第一个像素
    assert_eq!(image[1], [255, 0, 0]);
}
```

## 多维索引

`Idx` 可以是任意类型，支持多维索引：

```rust
use std::ops::Index;

struct Matrix {
    data: Vec<f64>,
    rows: usize,
    cols: usize,
}

// 使用元组作为索引类型
impl Index<(usize, usize)> for Matrix {
    type Output = f64;

    fn index(&self, (row, col): (usize, usize)) -> &f64 {
        &self.data[row * self.cols + col]
    }
}

fn main() {
    let m = Matrix {
        data: vec![1.0, 2.0, 3.0, 4.0],
        rows: 2,
        cols: 2,
    };
    assert_eq!(m[(0, 1)], 2.0);  // 第一行第二列
}
```

## 标准库实现

常见类型的 `Index` 实现：

| 类型 | 索引类型 | 返回类型 |
| --- | --- | --- |
| `Vec<T>` | `usize` | `&T` |
| `Vec<T>` | `Range<usize>` | `&[T]` |
| `[T]` | `usize` | `&T` |
| `str` | `Range<usize>` | `&str` |
| `HashMap<K, V>` | `&K` | `&V` |

```rust
fn main() {
    let v = vec![10, 20, 30, 40, 50];
    
    assert_eq!(v[2], 30);           // usize 索引
    assert_eq!(&v[1..4], [20, 30, 40]); // Range 索引
    
    let s = "hello";
    assert_eq!(&s[1..4], "ell");    // 字符串切片
}
```

## 注意事项

### 索引越界会 panic

`index()` 返回引用而非 `Option`，越界直接 panic：

```rust
fn main() {
    let v = vec![1, 2, 3];
    // let x = v[10]; // panic: index out of bounds
    
    // 安全访问用 get()
    let x = v.get(10); // 返回 Option<&T>
    assert_eq!(x, None);
}
```

### 自动解引用

`a[i]` 实际是 `*a.index(i)`，编译器自动解引用：

```rust
use std::ops::Index;

struct Wrapper(Vec<i32>);

impl Index<usize> for Wrapper {
    type Output = i32;
    fn index(&self, i: usize) -> &i32 {
        &self.0[i]  // 返回 &i32
    }
}

fn main() {
    let w = Wrapper(vec![1, 2, 3]);
    let x: i32 = w[0];  // 自动解引用，得到 i32
    let y: &i32 = &w[0]; // 取引用，得到 &i32
}
```

### 与 Deref 的区别

| 特性 | Index | Deref |
| --- | --- | --- |
| 语法 | `a[i]` | `*a` |
| 参数 | 需要索引值 | 无参数 |
| 用途 | 按位置访问元素 | 智能指针解引用 |
| 自动调用 | 仅 `[]` 语法 | 方法调用时自动 |

## 实践示例：环形缓冲区

```rust
use std::ops::{Index, IndexMut};

/// 环形缓冲区：固定容量，索引自动取模实现循环访问
struct RingBuffer<T> {
    data: Vec<T>,   // 底层存储
    head: usize,    // 逻辑起始位置
}

impl<T> RingBuffer<T> {
    fn new(capacity: usize) -> Self
    where
        T: Default + Clone,
    {
        RingBuffer {
            data: vec![T::default(); capacity],  // 预分配固定容量
            head: 0,
        }
    }
}

// 实现只读索引
impl<T> Index<usize> for RingBuffer<T> {
    type Output = T;

    fn index(&self, i: usize) -> &T {
        let len = self.data.len();
        // 关键：(head + i) % len 实现环形访问
        // 例如 capacity=4, head=2, i=3 → 实际索引 (2+3)%4 = 1
        &self.data[(self.head + i) % len]
    }
}

// 实现可变索引（必须先实现 Index）
impl<T> IndexMut<usize> for RingBuffer<T> {
    fn index_mut(&mut self, i: usize) -> &mut T {
        let len = self.data.len();
        &mut self.data[(self.head + i) % len]  // 同样的环形计算
    }
}

fn main() {
    let mut buf: RingBuffer<i32> = RingBuffer::new(4);
    
    buf[0] = 10;  // 调用 index_mut，可变访问
    buf[1] = 20;
    
    assert_eq!(buf[0], 10);  // 调用 index，只读访问
    assert_eq!(buf[1], 20);
}
```

## 总结

1. `Index` 重载 `[]` 只读访问，`IndexMut` 重载可变访问
2. `IndexMut` 必须先实现 `Index`（继承关系）
3. `Output` 支持动态大小类型，可返回切片
4. 索引越界会 panic，安全访问用 `get()` 方法
